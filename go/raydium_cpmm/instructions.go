// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package raydium_cp_swap

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "collect_fund_fee" instruction.
// Collect the fund fee accrued to the pool //  // # Arguments //  // * `ctx` - The context of accounts // * `amount_0_requested` - The maximum amount of token_0 to send, can be 0 to collect fees in only token_1 // * `amount_1_requested` - The maximum amount of token_1 to send, can be 0 to collect fees in only token_0 //
func NewCollectFundFeeInstruction(
	// Params:
	amount0RequestedParam uint64,
	amount1RequestedParam uint64,

	// Accounts:
	ownerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	token0VaultAccount solanago.PublicKey,
	token1VaultAccount solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
	recipientToken0AccountAccount solanago.PublicKey,
	recipientToken1AccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CollectFundFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amount0RequestedParam`:
		err = enc__.Encode(amount0RequestedParam)
		if err != nil {
			return nil, errors.NewField("amount0RequestedParam", err)
		}
		// Serialize `amount1RequestedParam`:
		err = enc__.Encode(amount1RequestedParam)
		if err != nil {
			return nil, errors.NewField("amount1RequestedParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		// Only admin or fund_owner can collect fee now
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		// Pool state stores accumulated protocol fee amount
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "amm_config": Read-only, Non-signer, Required
		// Amm config account stores fund_owner
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 4 "token_0_vault": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(token0VaultAccount, true, false))
		// Account 5 "token_1_vault": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(token1VaultAccount, true, false))
		// Account 6 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token_0 vault
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 7 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token_1 vault
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
		// Account 8 "recipient_token_0_account": Writable, Non-signer, Required
		// The address that receives the collected token_0 fund fees
		accounts__.Append(solanago.NewAccountMeta(recipientToken0AccountAccount, true, false))
		// Account 9 "recipient_token_1_account": Writable, Non-signer, Required
		// The address that receives the collected token_1 fund fees
		accounts__.Append(solanago.NewAccountMeta(recipientToken1AccountAccount, true, false))
		// Account 10 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// The SPL program to perform token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 11 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// The SPL program 2022 to perform token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "collect_protocol_fee" instruction.
// Collect the protocol fee accrued to the pool //  // # Arguments //  // * `ctx` - The context of accounts // * `amount_0_requested` - The maximum amount of token_0 to send, can be 0 to collect fees in only token_1 // * `amount_1_requested` - The maximum amount of token_1 to send, can be 0 to collect fees in only token_0 //
func NewCollectProtocolFeeInstruction(
	// Params:
	amount0RequestedParam uint64,
	amount1RequestedParam uint64,

	// Accounts:
	ownerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	token0VaultAccount solanago.PublicKey,
	token1VaultAccount solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
	recipientToken0AccountAccount solanago.PublicKey,
	recipientToken1AccountAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CollectProtocolFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amount0RequestedParam`:
		err = enc__.Encode(amount0RequestedParam)
		if err != nil {
			return nil, errors.NewField("amount0RequestedParam", err)
		}
		// Serialize `amount1RequestedParam`:
		err = enc__.Encode(amount1RequestedParam)
		if err != nil {
			return nil, errors.NewField("amount1RequestedParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		// Only admin or owner can collect fee now
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		// Pool state stores accumulated protocol fee amount
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "amm_config": Read-only, Non-signer, Required
		// Amm config account stores owner
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 4 "token_0_vault": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(token0VaultAccount, true, false))
		// Account 5 "token_1_vault": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(token1VaultAccount, true, false))
		// Account 6 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token_0 vault
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 7 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token_1 vault
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
		// Account 8 "recipient_token_0_account": Writable, Non-signer, Required
		// The address that receives the collected token_0 protocol fees
		accounts__.Append(solanago.NewAccountMeta(recipientToken0AccountAccount, true, false))
		// Account 9 "recipient_token_1_account": Writable, Non-signer, Required
		// The address that receives the collected token_1 protocol fees
		accounts__.Append(solanago.NewAccountMeta(recipientToken1AccountAccount, true, false))
		// Account 10 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// The SPL program to perform token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 11 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// The SPL program 2022 to perform token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_amm_config" instruction.
// # Arguments //  // * `ctx`- The accounts needed by instruction. // * `index` - The index of amm config, there may be multiple config. // * `trade_fee_rate` - Trade fee rate, can be changed. // * `protocol_fee_rate` - The rate of protocol fee within trade fee. // * `fund_fee_rate` - The rate of fund fee within trade fee. //
func NewCreateAmmConfigInstruction(
	// Params:
	indexParam uint16,
	tradeFeeRateParam uint64,
	protocolFeeRateParam uint64,
	fundFeeRateParam uint64,
	createPoolFeeParam uint64,

	// Accounts:
	ownerAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateAmmConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `indexParam`:
		err = enc__.Encode(indexParam)
		if err != nil {
			return nil, errors.NewField("indexParam", err)
		}
		// Serialize `tradeFeeRateParam`:
		err = enc__.Encode(tradeFeeRateParam)
		if err != nil {
			return nil, errors.NewField("tradeFeeRateParam", err)
		}
		// Serialize `protocolFeeRateParam`:
		err = enc__.Encode(protocolFeeRateParam)
		if err != nil {
			return nil, errors.NewField("protocolFeeRateParam", err)
		}
		// Serialize `fundFeeRateParam`:
		err = enc__.Encode(fundFeeRateParam)
		if err != nil {
			return nil, errors.NewField("fundFeeRateParam", err)
		}
		// Serialize `createPoolFeeParam`:
		err = enc__.Encode(createPoolFeeParam)
		if err != nil {
			return nil, errors.NewField("createPoolFeeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Writable, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		// Address to be set as protocol owner.
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, true, true))
		// Account 1 "amm_config": Writable, Non-signer, Required
		// Initialize config state account to store protocol owner address and fee rates.
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, true, false))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "deposit" instruction.
// Deposit lp token to the pool //  // # Arguments //  // * `ctx`- The context of accounts // * `lp_token_amount` - Pool token amount to transfer. token_a and token_b amount are set by the current exchange rate and size of the pool // * `maximum_token_0_amount` -  Maximum token 0 amount to deposit, prevents excessive slippage // * `maximum_token_1_amount` - Maximum token 1 amount to deposit, prevents excessive slippage //
func NewDepositInstruction(
	// Params:
	lpTokenAmountParam uint64,
	maximumToken0AmountParam uint64,
	maximumToken1AmountParam uint64,

	// Accounts:
	ownerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	ownerLpTokenAccount solanago.PublicKey,
	token0AccountAccount solanago.PublicKey,
	token1AccountAccount solanago.PublicKey,
	token0VaultAccount solanago.PublicKey,
	token1VaultAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Deposit[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lpTokenAmountParam`:
		err = enc__.Encode(lpTokenAmountParam)
		if err != nil {
			return nil, errors.NewField("lpTokenAmountParam", err)
		}
		// Serialize `maximumToken0AmountParam`:
		err = enc__.Encode(maximumToken0AmountParam)
		if err != nil {
			return nil, errors.NewField("maximumToken0AmountParam", err)
		}
		// Serialize `maximumToken1AmountParam`:
		err = enc__.Encode(maximumToken1AmountParam)
		if err != nil {
			return nil, errors.NewField("maximumToken1AmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		// Pays to mint the position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "owner_lp_token": Writable, Non-signer, Required
		// Owner lp token account
		accounts__.Append(solanago.NewAccountMeta(ownerLpTokenAccount, true, false))
		// Account 4 "token_0_account": Writable, Non-signer, Required
		// The payer's token account for token_0
		accounts__.Append(solanago.NewAccountMeta(token0AccountAccount, true, false))
		// Account 5 "token_1_account": Writable, Non-signer, Required
		// The payer's token account for token_1
		accounts__.Append(solanago.NewAccountMeta(token1AccountAccount, true, false))
		// Account 6 "token_0_vault": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(token0VaultAccount, true, false))
		// Account 7 "token_1_vault": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(token1VaultAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// token Program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Token program 2022
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 10 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token_0 vault
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 11 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token_1 vault
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
		// Account 12 "lp_mint": Writable, Non-signer, Required
		// Lp token mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize" instruction.
// Creates a pool for the given token pair and the initial price //  // # Arguments //  // * `ctx`- The context of accounts // * `init_amount_0` - the initial amount_0 to deposit // * `init_amount_1` - the initial amount_1 to deposit // * `open_time` - the timestamp allowed for swap //
func NewInitializeInstruction(
	// Params:
	initAmount0param uint64,
	initAmount1param uint64,
	openTimeParam uint64,

	// Accounts:
	creatorAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	token0MintAccount solanago.PublicKey,
	token1MintAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	creatorToken0account solanago.PublicKey,
	creatorToken1account solanago.PublicKey,
	creatorLpTokenAccount solanago.PublicKey,
	token0VaultAccount solanago.PublicKey,
	token1VaultAccount solanago.PublicKey,
	createPoolFeeAccount solanago.PublicKey,
	observationStateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	token0ProgramAccount solanago.PublicKey,
	token1ProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Initialize[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `initAmount0param`:
		err = enc__.Encode(initAmount0param)
		if err != nil {
			return nil, errors.NewField("initAmount0param", err)
		}
		// Serialize `initAmount1param`:
		err = enc__.Encode(initAmount1param)
		if err != nil {
			return nil, errors.NewField("initAmount1param", err)
		}
		// Serialize `openTimeParam`:
		err = enc__.Encode(openTimeParam)
		if err != nil {
			return nil, errors.NewField("openTimeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "creator": Writable, Signer, Required
		// Address paying to create the pool. Can be anyone
		accounts__.Append(solanago.NewAccountMeta(creatorAccount, true, true))
		// Account 1 "amm_config": Read-only, Non-signer, Required
		// Which config the pool belongs to.
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 2 "authority": Read-only, Non-signer, Required
		// pool vault and lp mint authority
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 3 "pool_state": Writable, Non-signer, Required
		// PDA account:
		// seeds = [
		// POOL_SEED.as_bytes(),
		// amm_config.key().as_ref(),
		// token_0_mint.key().as_ref(),
		// token_1_mint.key().as_ref(),
		// ],
		//
		// Or random account: must be signed by cli
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 4 "token_0_mint": Read-only, Non-signer, Required
		// Token_0 mint, the key must smaller than token_1 mint.
		accounts__.Append(solanago.NewAccountMeta(token0MintAccount, false, false))
		// Account 5 "token_1_mint": Read-only, Non-signer, Required
		// Token_1 mint, the key must grater then token_0 mint.
		accounts__.Append(solanago.NewAccountMeta(token1MintAccount, false, false))
		// Account 6 "lp_mint": Writable, Non-signer, Required
		// pool lp mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 7 "creator_token_0": Writable, Non-signer, Required
		// payer token0 account
		accounts__.Append(solanago.NewAccountMeta(creatorToken0account, true, false))
		// Account 8 "creator_token_1": Writable, Non-signer, Required
		// creator token1 account
		accounts__.Append(solanago.NewAccountMeta(creatorToken1account, true, false))
		// Account 9 "creator_lp_token": Writable, Non-signer, Required
		// creator lp token account
		accounts__.Append(solanago.NewAccountMeta(creatorLpTokenAccount, true, false))
		// Account 10 "token_0_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(token0VaultAccount, true, false))
		// Account 11 "token_1_vault": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(token1VaultAccount, true, false))
		// Account 12 "create_pool_fee": Writable, Non-signer, Required, Address: DNXgeM9EiiaAbaWvwjHj9fQQLAX5ZsfHyvmYUNRAdNC8
		// create pool fee account
		accounts__.Append(solanago.NewAccountMeta(createPoolFeeAccount, true, false))
		// Account 13 "observation_state": Writable, Non-signer, Required
		// an account to store oracle observations
		accounts__.Append(solanago.NewAccountMeta(observationStateAccount, true, false))
		// Account 14 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 15 "token_0_program": Read-only, Non-signer, Required
		// Spl token program or token program 2022
		accounts__.Append(solanago.NewAccountMeta(token0ProgramAccount, false, false))
		// Account 16 "token_1_program": Read-only, Non-signer, Required
		// Spl token program or token program 2022
		accounts__.Append(solanago.NewAccountMeta(token1ProgramAccount, false, false))
		// Account 17 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		// Program to create an ATA for receiving position NFT
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 18 "system_program": Read-only, Non-signer, Required
		// To create a new program account
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 19 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		// Sysvar for program account
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap_base_input" instruction.
// Swap the tokens in the pool base input amount //  // # Arguments //  // * `ctx`- The context of accounts // * `amount_in` -  input amount to transfer, output to DESTINATION is based on the exchange rate // * `minimum_amount_out` -  Minimum amount of output token, prevents excessive slippage //
func NewSwapBaseInputInstruction(
	// Params:
	amountInParam uint64,
	minimumAmountOutParam uint64,

	// Accounts:
	payerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	inputTokenAccountAccount solanago.PublicKey,
	outputTokenAccountAccount solanago.PublicKey,
	inputVaultAccount solanago.PublicKey,
	outputVaultAccount solanago.PublicKey,
	inputTokenProgramAccount solanago.PublicKey,
	outputTokenProgramAccount solanago.PublicKey,
	inputTokenMintAccount solanago.PublicKey,
	outputTokenMintAccount solanago.PublicKey,
	observationStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SwapBaseInput[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountInParam`:
		err = enc__.Encode(amountInParam)
		if err != nil {
			return nil, errors.NewField("amountInParam", err)
		}
		// Serialize `minimumAmountOutParam`:
		err = enc__.Encode(minimumAmountOutParam)
		if err != nil {
			return nil, errors.NewField("minimumAmountOutParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Read-only, Signer, Required
		// The user performing the swap
		accounts__.Append(solanago.NewAccountMeta(payerAccount, false, true))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "amm_config": Read-only, Non-signer, Required
		// The factory state to read protocol fees
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 3 "pool_state": Writable, Non-signer, Required
		// The program account of the pool in which the swap will be performed
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 4 "input_token_account": Writable, Non-signer, Required
		// The user token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputTokenAccountAccount, true, false))
		// Account 5 "output_token_account": Writable, Non-signer, Required
		// The user token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputTokenAccountAccount, true, false))
		// Account 6 "input_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputVaultAccount, true, false))
		// Account 7 "output_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputVaultAccount, true, false))
		// Account 8 "input_token_program": Read-only, Non-signer, Required
		// SPL program for input token transfers
		accounts__.Append(solanago.NewAccountMeta(inputTokenProgramAccount, false, false))
		// Account 9 "output_token_program": Read-only, Non-signer, Required
		// SPL program for output token transfers
		accounts__.Append(solanago.NewAccountMeta(outputTokenProgramAccount, false, false))
		// Account 10 "input_token_mint": Read-only, Non-signer, Required
		// The mint of input token
		accounts__.Append(solanago.NewAccountMeta(inputTokenMintAccount, false, false))
		// Account 11 "output_token_mint": Read-only, Non-signer, Required
		// The mint of output token
		accounts__.Append(solanago.NewAccountMeta(outputTokenMintAccount, false, false))
		// Account 12 "observation_state": Writable, Non-signer, Required
		// The program account for the most recent oracle observation
		accounts__.Append(solanago.NewAccountMeta(observationStateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap_base_output" instruction.
// Swap the tokens in the pool base output amount //  // # Arguments //  // * `ctx`- The context of accounts // * `max_amount_in` -  input amount prevents excessive slippage // * `amount_out` -  amount of output token //
func NewSwapBaseOutputInstruction(
	// Params:
	maxAmountInParam uint64,
	amountOutParam uint64,

	// Accounts:
	payerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	inputTokenAccountAccount solanago.PublicKey,
	outputTokenAccountAccount solanago.PublicKey,
	inputVaultAccount solanago.PublicKey,
	outputVaultAccount solanago.PublicKey,
	inputTokenProgramAccount solanago.PublicKey,
	outputTokenProgramAccount solanago.PublicKey,
	inputTokenMintAccount solanago.PublicKey,
	outputTokenMintAccount solanago.PublicKey,
	observationStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SwapBaseOutput[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `maxAmountInParam`:
		err = enc__.Encode(maxAmountInParam)
		if err != nil {
			return nil, errors.NewField("maxAmountInParam", err)
		}
		// Serialize `amountOutParam`:
		err = enc__.Encode(amountOutParam)
		if err != nil {
			return nil, errors.NewField("amountOutParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Read-only, Signer, Required
		// The user performing the swap
		accounts__.Append(solanago.NewAccountMeta(payerAccount, false, true))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "amm_config": Read-only, Non-signer, Required
		// The factory state to read protocol fees
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 3 "pool_state": Writable, Non-signer, Required
		// The program account of the pool in which the swap will be performed
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 4 "input_token_account": Writable, Non-signer, Required
		// The user token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputTokenAccountAccount, true, false))
		// Account 5 "output_token_account": Writable, Non-signer, Required
		// The user token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputTokenAccountAccount, true, false))
		// Account 6 "input_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputVaultAccount, true, false))
		// Account 7 "output_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputVaultAccount, true, false))
		// Account 8 "input_token_program": Read-only, Non-signer, Required
		// SPL program for input token transfers
		accounts__.Append(solanago.NewAccountMeta(inputTokenProgramAccount, false, false))
		// Account 9 "output_token_program": Read-only, Non-signer, Required
		// SPL program for output token transfers
		accounts__.Append(solanago.NewAccountMeta(outputTokenProgramAccount, false, false))
		// Account 10 "input_token_mint": Read-only, Non-signer, Required
		// The mint of input token
		accounts__.Append(solanago.NewAccountMeta(inputTokenMintAccount, false, false))
		// Account 11 "output_token_mint": Read-only, Non-signer, Required
		// The mint of output token
		accounts__.Append(solanago.NewAccountMeta(outputTokenMintAccount, false, false))
		// Account 12 "observation_state": Writable, Non-signer, Required
		// The program account for the most recent oracle observation
		accounts__.Append(solanago.NewAccountMeta(observationStateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_amm_config" instruction.
// Updates the owner of the amm config // Must be called by the current owner or admin //  // # Arguments //  // * `ctx`- The context of accounts // * `trade_fee_rate`- The new trade fee rate of amm config, be set when `param` is 0 // * `protocol_fee_rate`- The new protocol fee rate of amm config, be set when `param` is 1 // * `fund_fee_rate`- The new fund fee rate of amm config, be set when `param` is 2 // * `new_owner`- The config's new owner, be set when `param` is 3 // * `new_fund_owner`- The config's new fund owner, be set when `param` is 4 // * `param`- The value can be 0 | 1 | 2 | 3 | 4, otherwise will report a error //
func NewUpdateAmmConfigInstruction(
	// Params:
	paramParam uint8,
	valueParam uint64,

	// Accounts:
	ownerAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateAmmConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramParam`:
		err = enc__.Encode(paramParam)
		if err != nil {
			return nil, errors.NewField("paramParam", err)
		}
		// Serialize `valueParam`:
		err = enc__.Encode(valueParam)
		if err != nil {
			return nil, errors.NewField("valueParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		// The amm config owner or admin
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "amm_config": Writable, Non-signer, Required
		// Amm config account to be changed
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_pool_status" instruction.
// Update pool status for given value //  // # Arguments //  // * `ctx`- The context of accounts // * `status` - The value of status //
func NewUpdatePoolStatusInstruction(
	// Params:
	statusParam uint8,

	// Accounts:
	authorityAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePoolStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "withdraw" instruction.
// Withdraw lp for token0 and token1 //  // # Arguments //  // * `ctx`- The context of accounts // * `lp_token_amount` - Amount of pool tokens to burn. User receives an output of token a and b based on the percentage of the pool tokens that are returned. // * `minimum_token_0_amount` -  Minimum amount of token 0 to receive, prevents excessive slippage // * `minimum_token_1_amount` -  Minimum amount of token 1 to receive, prevents excessive slippage //
func NewWithdrawInstruction(
	// Params:
	lpTokenAmountParam uint64,
	minimumToken0AmountParam uint64,
	minimumToken1AmountParam uint64,

	// Accounts:
	ownerAccount solanago.PublicKey,
	authorityAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	ownerLpTokenAccount solanago.PublicKey,
	token0AccountAccount solanago.PublicKey,
	token1AccountAccount solanago.PublicKey,
	token0VaultAccount solanago.PublicKey,
	token1VaultAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
	lpMintAccount solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Withdraw[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `lpTokenAmountParam`:
		err = enc__.Encode(lpTokenAmountParam)
		if err != nil {
			return nil, errors.NewField("lpTokenAmountParam", err)
		}
		// Serialize `minimumToken0AmountParam`:
		err = enc__.Encode(minimumToken0AmountParam)
		if err != nil {
			return nil, errors.NewField("minimumToken0AmountParam", err)
		}
		// Serialize `minimumToken1AmountParam`:
		err = enc__.Encode(minimumToken1AmountParam)
		if err != nil {
			return nil, errors.NewField("minimumToken1AmountParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		// Pays to mint the position
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "authority": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		// Pool state account
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "owner_lp_token": Writable, Non-signer, Required
		// Owner lp token account
		accounts__.Append(solanago.NewAccountMeta(ownerLpTokenAccount, true, false))
		// Account 4 "token_0_account": Writable, Non-signer, Required
		// The token account for receive token_0,
		accounts__.Append(solanago.NewAccountMeta(token0AccountAccount, true, false))
		// Account 5 "token_1_account": Writable, Non-signer, Required
		// The token account for receive token_1
		accounts__.Append(solanago.NewAccountMeta(token1AccountAccount, true, false))
		// Account 6 "token_0_vault": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(token0VaultAccount, true, false))
		// Account 7 "token_1_vault": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(token1VaultAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// token Program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Token program 2022
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 10 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token_0 vault
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 11 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token_1 vault
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
		// Account 12 "lp_mint": Writable, Non-signer, Required
		// Pool lp token mint
		accounts__.Append(solanago.NewAccountMeta(lpMintAccount, true, false))
		// Account 13 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		// memo program
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}
