// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains instructions.

package amm_v3

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Builds a "close_position" instruction.
// Close the user's position and NFT account. If the NFT mint belongs to token2022, it will also be closed and the funds returned to the NFT owner. //  // # Arguments //  // * `ctx` - The context of accounts //
func NewClosePositionInstruction(
	nftOwnerAccount solanago.PublicKey,
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	personalPositionAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "nft_owner": Writable, Signer, Required
		// The position nft owner
		accounts__.Append(solanago.NewAccountMeta(nftOwnerAccount, true, true))
		// Account 1 "position_nft_mint": Writable, Non-signer, Required
		// Mint address bound to the personal position.
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, false))
		// Account 2 "position_nft_account": Writable, Non-signer, Required
		// User token account where position NFT be minted to
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 3 "personal_position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(personalPositionAccount, true, false))
		// Account 4 "system_program": Read-only, Non-signer, Required
		// System program to close the position state account
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 5 "token_program": Read-only, Non-signer, Required
		// Token/Token2022 program to close token/mint account
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "collect_fund_fee" instruction.
// Collect the fund fee accrued to the pool //  // # Arguments //  // * `ctx` - The context of accounts // * `amount_0_requested` - The maximum amount of token_0 to send // * `amount_1_requested` - The maximum amount of token_1 to send //
func NewCollectFundFeeInstruction(
	// Params:
	amount0RequestedParam uint64,
	amount1RequestedParam uint64,

	// Accounts:
	ownerAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
	recipientTokenAccount0account solanago.PublicKey,
	recipientTokenAccount1account solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CollectFundFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amount0RequestedParam`:
		err = enc__.Encode(amount0RequestedParam)
		if err != nil {
			return nil, errors.NewField("amount0RequestedParam", err)
		}
		// Serialize `amount1RequestedParam`:
		err = enc__.Encode(amount1RequestedParam)
		if err != nil {
			return nil, errors.NewField("amount1RequestedParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		// Only admin or fund_owner can collect fee now
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "pool_state": Writable, Non-signer, Required
		// Pool state stores accumulated protocol fee amount
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 2 "amm_config": Read-only, Non-signer, Required
		// Amm config account stores fund_owner
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 3 "token_vault_0": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 4 "token_vault_1": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 5 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token vault 0
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 6 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token vault 1
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
		// Account 7 "recipient_token_account_0": Writable, Non-signer, Required
		// The address that receives the collected token_0 protocol fees
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount0account, true, false))
		// Account 8 "recipient_token_account_1": Writable, Non-signer, Required
		// The address that receives the collected token_1 protocol fees
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount1account, true, false))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// The SPL program to perform token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// The SPL program 2022 to perform token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "collect_protocol_fee" instruction.
// Collect the protocol fee accrued to the pool //  // # Arguments //  // * `ctx` - The context of accounts // * `amount_0_requested` - The maximum amount of token_0 to send // * `amount_1_requested` - The maximum amount of token_1 to send //
func NewCollectProtocolFeeInstruction(
	// Params:
	amount0RequestedParam uint64,
	amount1RequestedParam uint64,

	// Accounts:
	ownerAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
	recipientTokenAccount0account solanago.PublicKey,
	recipientTokenAccount1account solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CollectProtocolFee[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amount0RequestedParam`:
		err = enc__.Encode(amount0RequestedParam)
		if err != nil {
			return nil, errors.NewField("amount0RequestedParam", err)
		}
		// Serialize `amount1RequestedParam`:
		err = enc__.Encode(amount1RequestedParam)
		if err != nil {
			return nil, errors.NewField("amount1RequestedParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required
		// Only admin or config owner can collect fee now
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "pool_state": Writable, Non-signer, Required
		// Pool state stores accumulated protocol fee amount
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 2 "amm_config": Read-only, Non-signer, Required
		// Amm config account stores owner
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 3 "token_vault_0": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 4 "token_vault_1": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 5 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token vault 0
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 6 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token vault 1
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
		// Account 7 "recipient_token_account_0": Writable, Non-signer, Required
		// The address that receives the collected token_0 protocol fees
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount0account, true, false))
		// Account 8 "recipient_token_account_1": Writable, Non-signer, Required
		// The address that receives the collected token_1 protocol fees
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount1account, true, false))
		// Account 9 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// The SPL program to perform token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 10 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// The SPL program 2022 to perform token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "collect_remaining_rewards" instruction.
// Collect remaining reward token for reward founder //  // # Arguments //  // * `ctx`- The context of accounts // * `reward_index` - the index to reward info, it must be smaller than 3 //
func NewCollectRemainingRewardsInstruction(
	// Params:
	rewardIndexParam uint8,

	// Accounts:
	rewardFunderAccount solanago.PublicKey,
	funderTokenAccountAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	rewardTokenVaultAccount solanago.PublicKey,
	rewardVaultMintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CollectRemainingRewards[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "reward_funder": Read-only, Signer, Required
		// The founder who init reward info previously
		accounts__.Append(solanago.NewAccountMeta(rewardFunderAccount, false, true))
		// Account 1 "funder_token_account": Writable, Non-signer, Required
		// The funder's reward token account
		accounts__.Append(solanago.NewAccountMeta(funderTokenAccountAccount, true, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		// Set reward for this pool
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "reward_token_vault": Read-only, Non-signer, Required
		// Reward vault transfer remaining token to founder token account
		accounts__.Append(solanago.NewAccountMeta(rewardTokenVaultAccount, false, false))
		// Account 4 "reward_vault_mint": Read-only, Non-signer, Required
		// The mint of reward token vault
		accounts__.Append(solanago.NewAccountMeta(rewardVaultMintAccount, false, false))
		// Account 5 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 6 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Token program 2022
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 7 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		// memo program
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_amm_config" instruction.
// # Arguments //  // * `ctx`- The accounts needed by instruction. // * `index` - The index of amm config, there may be multiple config. // * `tick_spacing` - The tickspacing binding with config, cannot be changed. // * `trade_fee_rate` - Trade fee rate, can be changed. // * `protocol_fee_rate` - The rate of protocol fee within trade fee. // * `fund_fee_rate` - The rate of fund fee within trade fee. //
func NewCreateAmmConfigInstruction(
	// Params:
	indexParam uint16,
	tickSpacingParam uint16,
	tradeFeeRateParam uint32,
	protocolFeeRateParam uint32,
	fundFeeRateParam uint32,

	// Accounts:
	ownerAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreateAmmConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `indexParam`:
		err = enc__.Encode(indexParam)
		if err != nil {
			return nil, errors.NewField("indexParam", err)
		}
		// Serialize `tickSpacingParam`:
		err = enc__.Encode(tickSpacingParam)
		if err != nil {
			return nil, errors.NewField("tickSpacingParam", err)
		}
		// Serialize `tradeFeeRateParam`:
		err = enc__.Encode(tradeFeeRateParam)
		if err != nil {
			return nil, errors.NewField("tradeFeeRateParam", err)
		}
		// Serialize `protocolFeeRateParam`:
		err = enc__.Encode(protocolFeeRateParam)
		if err != nil {
			return nil, errors.NewField("protocolFeeRateParam", err)
		}
		// Serialize `fundFeeRateParam`:
		err = enc__.Encode(fundFeeRateParam)
		if err != nil {
			return nil, errors.NewField("fundFeeRateParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Writable, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		// Address to be set as protocol owner.
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, true, true))
		// Account 1 "amm_config": Writable, Non-signer, Required
		// Initialize config state account to store protocol owner address and fee rates.
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, true, false))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_operation_account" instruction.
// Creates an operation account for the program //  // # Arguments //  // * `ctx`- The context of accounts //
func NewCreateOperationAccountInstruction(
	ownerAccount solanago.PublicKey,
	operationStateAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Writable, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		// Address to be set as operation account owner.
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, true, true))
		// Account 1 "operation_state": Writable, Non-signer, Required
		// Initialize operation state account to store operation owner address and white list mint.
		accounts__.Append(solanago.NewAccountMeta(operationStateAccount, true, false))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "create_pool" instruction.
// Creates a pool for the given token pair and the initial price //  // # Arguments //  // * `ctx`- The context of accounts // * `sqrt_price_x64` - the initial sqrt price (amount_token_1 / amount_token_0) of the pool as a Q64.64 // Note: The open_time must be smaller than the current block_timestamp on chain.
func NewCreatePoolInstruction(
	// Params:
	sqrtPriceX64Param binary.Uint128,
	openTimeParam uint64,

	// Accounts:
	poolCreatorAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	tokenMint0account solanago.PublicKey,
	tokenMint1account solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	observationStateAccount solanago.PublicKey,
	tickArrayBitmapAccount solanago.PublicKey,
	tokenProgram0account solanago.PublicKey,
	tokenProgram1account solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_CreatePool[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `sqrtPriceX64Param`:
		err = enc__.Encode(sqrtPriceX64Param)
		if err != nil {
			return nil, errors.NewField("sqrtPriceX64Param", err)
		}
		// Serialize `openTimeParam`:
		err = enc__.Encode(openTimeParam)
		if err != nil {
			return nil, errors.NewField("openTimeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_creator": Writable, Signer, Required
		// Address paying to create the pool. Can be anyone
		accounts__.Append(solanago.NewAccountMeta(poolCreatorAccount, true, true))
		// Account 1 "amm_config": Read-only, Non-signer, Required
		// Which config the pool belongs to.
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		// Initialize an account to store the pool state
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "token_mint_0": Read-only, Non-signer, Required
		// Token_0 mint, the key must be smaller then token_1 mint.
		accounts__.Append(solanago.NewAccountMeta(tokenMint0account, false, false))
		// Account 4 "token_mint_1": Read-only, Non-signer, Required
		// Token_1 mint
		accounts__.Append(solanago.NewAccountMeta(tokenMint1account, false, false))
		// Account 5 "token_vault_0": Writable, Non-signer, Required
		// Token_0 vault for the pool
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 6 "token_vault_1": Writable, Non-signer, Required
		// Token_1 vault for the pool
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 7 "observation_state": Writable, Non-signer, Required
		// Initialize an account to store oracle observations
		accounts__.Append(solanago.NewAccountMeta(observationStateAccount, true, false))
		// Account 8 "tick_array_bitmap": Writable, Non-signer, Required
		// Initialize an account to store if a tick array is initialized.
		accounts__.Append(solanago.NewAccountMeta(tickArrayBitmapAccount, true, false))
		// Account 9 "token_program_0": Read-only, Non-signer, Required
		// Spl token program or token program 2022
		accounts__.Append(solanago.NewAccountMeta(tokenProgram0account, false, false))
		// Account 10 "token_program_1": Read-only, Non-signer, Required
		// Spl token program or token program 2022
		accounts__.Append(solanago.NewAccountMeta(tokenProgram1account, false, false))
		// Account 11 "system_program": Read-only, Non-signer, Required
		// To create a new program account
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 12 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		// Sysvar for program account
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "create_support_mint_associated" instruction.
// Create support token22 mint account which can create pool and send rewards with ignoring the not support extensions.
func NewCreateSupportMintAssociatedInstruction(
	ownerAccount solanago.PublicKey,
	tokenMintAccount solanago.PublicKey,
	supportMintAssociatedAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Writable, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		// Address to be set as protocol owner.
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, true, true))
		// Account 1 "token_mint": Read-only, Non-signer, Required
		// Support token mint
		accounts__.Append(solanago.NewAccountMeta(tokenMintAccount, false, false))
		// Account 2 "support_mint_associated": Writable, Non-signer, Required
		// Initialize support mint state account to store support mint address and bump.
		accounts__.Append(solanago.NewAccountMeta(supportMintAssociatedAccount, true, false))
		// Account 3 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}

// Builds a "decrease_liquidity" instruction.
// #[deprecated(note = "Use `decrease_liquidity_v2` instead.")] // Decreases liquidity for an existing position //  // # Arguments //  // * `ctx` -  The context of accounts // * `liquidity` - The amount by which liquidity will be decreased // * `amount_0_min` - The minimum amount of token_0 that should be accounted for the burned liquidity // * `amount_1_min` - The minimum amount of token_1 that should be accounted for the burned liquidity //
func NewDecreaseLiquidityInstruction(
	// Params:
	liquidityParam binary.Uint128,
	amount0MinParam uint64,
	amount1MinParam uint64,

	// Accounts:
	nftOwnerAccount solanago.PublicKey,
	nftAccountAccount solanago.PublicKey,
	personalPositionAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	protocolPositionAccount solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	tickArrayLowerAccount solanago.PublicKey,
	tickArrayUpperAccount solanago.PublicKey,
	recipientTokenAccount0account solanago.PublicKey,
	recipientTokenAccount1account solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DecreaseLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParam`:
		err = enc__.Encode(liquidityParam)
		if err != nil {
			return nil, errors.NewField("liquidityParam", err)
		}
		// Serialize `amount0MinParam`:
		err = enc__.Encode(amount0MinParam)
		if err != nil {
			return nil, errors.NewField("amount0MinParam", err)
		}
		// Serialize `amount1MinParam`:
		err = enc__.Encode(amount1MinParam)
		if err != nil {
			return nil, errors.NewField("amount1MinParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "nft_owner": Read-only, Signer, Required
		// The position owner or delegated authority
		accounts__.Append(solanago.NewAccountMeta(nftOwnerAccount, false, true))
		// Account 1 "nft_account": Read-only, Non-signer, Required
		// The token account for the tokenized position
		accounts__.Append(solanago.NewAccountMeta(nftAccountAccount, false, false))
		// Account 2 "personal_position": Writable, Non-signer, Required
		// Decrease liquidity for this position
		accounts__.Append(solanago.NewAccountMeta(personalPositionAccount, true, false))
		// Account 3 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 4 "protocol_position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolPositionAccount, true, false))
		// Account 5 "token_vault_0": Writable, Non-signer, Required
		// Token_0 vault
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 6 "token_vault_1": Writable, Non-signer, Required
		// Token_1 vault
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 7 "tick_array_lower": Writable, Non-signer, Required
		// Stores init state for the lower tick
		accounts__.Append(solanago.NewAccountMeta(tickArrayLowerAccount, true, false))
		// Account 8 "tick_array_upper": Writable, Non-signer, Required
		// Stores init state for the upper tick
		accounts__.Append(solanago.NewAccountMeta(tickArrayUpperAccount, true, false))
		// Account 9 "recipient_token_account_0": Writable, Non-signer, Required
		// The destination token account for receive amount_0
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount0account, true, false))
		// Account 10 "recipient_token_account_1": Writable, Non-signer, Required
		// The destination token account for receive amount_1
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount1account, true, false))
		// Account 11 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// SPL program to transfer out tokens
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "decrease_liquidity_v2" instruction.
// Decreases liquidity for an existing position, support Token2022 //  // # Arguments //  // * `ctx` -  The context of accounts // * `liquidity` - The amount by which liquidity will be decreased // * `amount_0_min` - The minimum amount of token_0 that should be accounted for the burned liquidity // * `amount_1_min` - The minimum amount of token_1 that should be accounted for the burned liquidity //
func NewDecreaseLiquidityV2Instruction(
	// Params:
	liquidityParam binary.Uint128,
	amount0MinParam uint64,
	amount1MinParam uint64,

	// Accounts:
	nftOwnerAccount solanago.PublicKey,
	nftAccountAccount solanago.PublicKey,
	personalPositionAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	protocolPositionAccount solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	tickArrayLowerAccount solanago.PublicKey,
	tickArrayUpperAccount solanago.PublicKey,
	recipientTokenAccount0account solanago.PublicKey,
	recipientTokenAccount1account solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_DecreaseLiquidityV2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParam`:
		err = enc__.Encode(liquidityParam)
		if err != nil {
			return nil, errors.NewField("liquidityParam", err)
		}
		// Serialize `amount0MinParam`:
		err = enc__.Encode(amount0MinParam)
		if err != nil {
			return nil, errors.NewField("amount0MinParam", err)
		}
		// Serialize `amount1MinParam`:
		err = enc__.Encode(amount1MinParam)
		if err != nil {
			return nil, errors.NewField("amount1MinParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "nft_owner": Read-only, Signer, Required
		// The position owner or delegated authority
		accounts__.Append(solanago.NewAccountMeta(nftOwnerAccount, false, true))
		// Account 1 "nft_account": Read-only, Non-signer, Required
		// The token account for the tokenized position
		accounts__.Append(solanago.NewAccountMeta(nftAccountAccount, false, false))
		// Account 2 "personal_position": Writable, Non-signer, Required
		// Decrease liquidity for this position
		accounts__.Append(solanago.NewAccountMeta(personalPositionAccount, true, false))
		// Account 3 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 4 "protocol_position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolPositionAccount, true, false))
		// Account 5 "token_vault_0": Writable, Non-signer, Required
		// Token_0 vault
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 6 "token_vault_1": Writable, Non-signer, Required
		// Token_1 vault
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 7 "tick_array_lower": Writable, Non-signer, Required
		// Stores init state for the lower tick
		accounts__.Append(solanago.NewAccountMeta(tickArrayLowerAccount, true, false))
		// Account 8 "tick_array_upper": Writable, Non-signer, Required
		// Stores init state for the upper tick
		accounts__.Append(solanago.NewAccountMeta(tickArrayUpperAccount, true, false))
		// Account 9 "recipient_token_account_0": Writable, Non-signer, Required
		// The destination token account for receive amount_0
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount0account, true, false))
		// Account 10 "recipient_token_account_1": Writable, Non-signer, Required
		// The destination token account for receive amount_1
		accounts__.Append(solanago.NewAccountMeta(recipientTokenAccount1account, true, false))
		// Account 11 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// SPL program to transfer out tokens
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 12 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Token program 2022
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 13 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		// memo program
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 14 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token vault 0
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 15 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token vault 1
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "increase_liquidity" instruction.
// #[deprecated(note = "Use `increase_liquidity_v2` instead.")] // Increases liquidity for an existing position, with amount paid by `payer` //  // # Arguments //  // * `ctx` - The context of accounts // * `liquidity` - The desired liquidity to be added, can't be zero // * `amount_0_max` - The max amount of token_0 to spend, which serves as a slippage check // * `amount_1_max` - The max amount of token_1 to spend, which serves as a slippage check //
func NewIncreaseLiquidityInstruction(
	// Params:
	liquidityParam binary.Uint128,
	amount0MaxParam uint64,
	amount1MaxParam uint64,

	// Accounts:
	nftOwnerAccount solanago.PublicKey,
	nftAccountAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	protocolPositionAccount solanago.PublicKey,
	personalPositionAccount solanago.PublicKey,
	tickArrayLowerAccount solanago.PublicKey,
	tickArrayUpperAccount solanago.PublicKey,
	tokenAccount0account solanago.PublicKey,
	tokenAccount1account solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IncreaseLiquidity[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParam`:
		err = enc__.Encode(liquidityParam)
		if err != nil {
			return nil, errors.NewField("liquidityParam", err)
		}
		// Serialize `amount0MaxParam`:
		err = enc__.Encode(amount0MaxParam)
		if err != nil {
			return nil, errors.NewField("amount0MaxParam", err)
		}
		// Serialize `amount1MaxParam`:
		err = enc__.Encode(amount1MaxParam)
		if err != nil {
			return nil, errors.NewField("amount1MaxParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "nft_owner": Read-only, Signer, Required
		// Pays to mint the position
		accounts__.Append(solanago.NewAccountMeta(nftOwnerAccount, false, true))
		// Account 1 "nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(nftAccountAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "protocol_position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolPositionAccount, true, false))
		// Account 4 "personal_position": Writable, Non-signer, Required
		// Increase liquidity for this position
		accounts__.Append(solanago.NewAccountMeta(personalPositionAccount, true, false))
		// Account 5 "tick_array_lower": Writable, Non-signer, Required
		// Stores init state for the lower tick
		accounts__.Append(solanago.NewAccountMeta(tickArrayLowerAccount, true, false))
		// Account 6 "tick_array_upper": Writable, Non-signer, Required
		// Stores init state for the upper tick
		accounts__.Append(solanago.NewAccountMeta(tickArrayUpperAccount, true, false))
		// Account 7 "token_account_0": Writable, Non-signer, Required
		// The payer's token account for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenAccount0account, true, false))
		// Account 8 "token_account_1": Writable, Non-signer, Required
		// The token account spending token_1 to mint the position
		accounts__.Append(solanago.NewAccountMeta(tokenAccount1account, true, false))
		// Account 9 "token_vault_0": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 10 "token_vault_1": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 11 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "increase_liquidity_v2" instruction.
// Increases liquidity for an existing position, with amount paid by `payer`, support Token2022 //  // # Arguments //  // * `ctx` - The context of accounts // * `liquidity` - The desired liquidity to be added, if zero, calculate liquidity base amount_0 or amount_1 according base_flag // * `amount_0_max` - The max amount of token_0 to spend, which serves as a slippage check // * `amount_1_max` - The max amount of token_1 to spend, which serves as a slippage check // * `base_flag` - must be specified if liquidity is zero, true: calculate liquidity base amount_0_max otherwise base amount_1_max //
func NewIncreaseLiquidityV2Instruction(
	// Params:
	liquidityParam binary.Uint128,
	amount0MaxParam uint64,
	amount1MaxParam uint64,
	baseFlagParam *bool,

	// Accounts:
	nftOwnerAccount solanago.PublicKey,
	nftAccountAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	protocolPositionAccount solanago.PublicKey,
	personalPositionAccount solanago.PublicKey,
	tickArrayLowerAccount solanago.PublicKey,
	tickArrayUpperAccount solanago.PublicKey,
	tokenAccount0account solanago.PublicKey,
	tokenAccount1account solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_IncreaseLiquidityV2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `liquidityParam`:
		err = enc__.Encode(liquidityParam)
		if err != nil {
			return nil, errors.NewField("liquidityParam", err)
		}
		// Serialize `amount0MaxParam`:
		err = enc__.Encode(amount0MaxParam)
		if err != nil {
			return nil, errors.NewField("amount0MaxParam", err)
		}
		// Serialize `amount1MaxParam`:
		err = enc__.Encode(amount1MaxParam)
		if err != nil {
			return nil, errors.NewField("amount1MaxParam", err)
		}
		// Serialize `baseFlagParam` (optional):
		{
			if baseFlagParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("baseFlagParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("baseFlagParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(baseFlagParam)
				if err != nil {
					return nil, errors.NewField("baseFlagParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "nft_owner": Read-only, Signer, Required
		// Pays to mint the position
		accounts__.Append(solanago.NewAccountMeta(nftOwnerAccount, false, true))
		// Account 1 "nft_account": Read-only, Non-signer, Required
		// The token account for nft
		accounts__.Append(solanago.NewAccountMeta(nftAccountAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "protocol_position": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(protocolPositionAccount, true, false))
		// Account 4 "personal_position": Writable, Non-signer, Required
		// Increase liquidity for this position
		accounts__.Append(solanago.NewAccountMeta(personalPositionAccount, true, false))
		// Account 5 "tick_array_lower": Writable, Non-signer, Required
		// Stores init state for the lower tick
		accounts__.Append(solanago.NewAccountMeta(tickArrayLowerAccount, true, false))
		// Account 6 "tick_array_upper": Writable, Non-signer, Required
		// Stores init state for the upper tick
		accounts__.Append(solanago.NewAccountMeta(tickArrayUpperAccount, true, false))
		// Account 7 "token_account_0": Writable, Non-signer, Required
		// The payer's token account for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenAccount0account, true, false))
		// Account 8 "token_account_1": Writable, Non-signer, Required
		// The token account spending token_1 to mint the position
		accounts__.Append(solanago.NewAccountMeta(tokenAccount1account, true, false))
		// Account 9 "token_vault_0": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 10 "token_vault_1": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 11 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 12 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Token program 2022
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 13 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token vault 0
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 14 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token vault 1
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "initialize_reward" instruction.
// Initialize a reward info for a given pool and reward index //  // # Arguments //  // * `ctx`- The context of accounts // * `reward_index` - the index to reward info // * `open_time` - reward open timestamp // * `end_time` - reward end timestamp // * `emissions_per_second_x64` - Token reward per second are earned per unit of liquidity. //
func NewInitializeRewardInstruction(
	// Params:
	paramParam InitializeRewardParam,

	// Accounts:
	rewardFunderAccount solanago.PublicKey,
	funderTokenAccountAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	operationStateAccount solanago.PublicKey,
	rewardTokenMintAccount solanago.PublicKey,
	rewardTokenVaultAccount solanago.PublicKey,
	rewardTokenProgramAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	rentAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_InitializeReward[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramParam`:
		err = enc__.Encode(paramParam)
		if err != nil {
			return nil, errors.NewField("paramParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "reward_funder": Writable, Signer, Required
		// The founder deposit reward token to vault
		accounts__.Append(solanago.NewAccountMeta(rewardFunderAccount, true, true))
		// Account 1 "funder_token_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(funderTokenAccountAccount, true, false))
		// Account 2 "amm_config": Read-only, Non-signer, Required
		// For check the reward_funder authority
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 3 "pool_state": Writable, Non-signer, Required
		// Set reward for this pool
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 4 "operation_state": Read-only, Non-signer, Required
		// load info from the account to judge reward permission
		accounts__.Append(solanago.NewAccountMeta(operationStateAccount, false, false))
		// Account 5 "reward_token_mint": Read-only, Non-signer, Required
		// Reward mint
		accounts__.Append(solanago.NewAccountMeta(rewardTokenMintAccount, false, false))
		// Account 6 "reward_token_vault": Writable, Non-signer, Required
		// A pda, reward vault
		accounts__.Append(solanago.NewAccountMeta(rewardTokenVaultAccount, true, false))
		// Account 7 "reward_token_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(rewardTokenProgramAccount, false, false))
		// Account 8 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 9 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "open_position" instruction.
// #[deprecated(note = "Use `open_position_with_token22_nft` instead.")] // Creates a new position wrapped in a NFT //  // # Arguments //  // * `ctx` - The context of accounts // * `tick_lower_index` - The low boundary of market // * `tick_upper_index` - The upper boundary of market // * `tick_array_lower_start_index` - The start index of tick array which include tick low // * `tick_array_upper_start_index` - The start index of tick array which include tick upper // * `liquidity` - The liquidity to be added // * `amount_0_max` - The max amount of token_0 to spend, which serves as a slippage check // * `amount_1_max` - The max amount of token_1 to spend, which serves as a slippage check //
func NewOpenPositionInstruction(
	// Params:
	tickLowerIndexParam int32,
	tickUpperIndexParam int32,
	tickArrayLowerStartIndexParam int32,
	tickArrayUpperStartIndexParam int32,
	liquidityParam binary.Uint128,
	amount0MaxParam uint64,
	amount1MaxParam uint64,

	// Accounts:
	payerAccount solanago.PublicKey,
	positionNftOwnerAccount solanago.PublicKey,
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	metadataAccountAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	protocolPositionAccount solanago.PublicKey,
	tickArrayLowerAccount solanago.PublicKey,
	tickArrayUpperAccount solanago.PublicKey,
	personalPositionAccount solanago.PublicKey,
	tokenAccount0account solanago.PublicKey,
	tokenAccount1account solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	metadataProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OpenPosition[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tickLowerIndexParam`:
		err = enc__.Encode(tickLowerIndexParam)
		if err != nil {
			return nil, errors.NewField("tickLowerIndexParam", err)
		}
		// Serialize `tickUpperIndexParam`:
		err = enc__.Encode(tickUpperIndexParam)
		if err != nil {
			return nil, errors.NewField("tickUpperIndexParam", err)
		}
		// Serialize `tickArrayLowerStartIndexParam`:
		err = enc__.Encode(tickArrayLowerStartIndexParam)
		if err != nil {
			return nil, errors.NewField("tickArrayLowerStartIndexParam", err)
		}
		// Serialize `tickArrayUpperStartIndexParam`:
		err = enc__.Encode(tickArrayUpperStartIndexParam)
		if err != nil {
			return nil, errors.NewField("tickArrayUpperStartIndexParam", err)
		}
		// Serialize `liquidityParam`:
		err = enc__.Encode(liquidityParam)
		if err != nil {
			return nil, errors.NewField("liquidityParam", err)
		}
		// Serialize `amount0MaxParam`:
		err = enc__.Encode(amount0MaxParam)
		if err != nil {
			return nil, errors.NewField("amount0MaxParam", err)
		}
		// Serialize `amount1MaxParam`:
		err = enc__.Encode(amount1MaxParam)
		if err != nil {
			return nil, errors.NewField("amount1MaxParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		// Pays to mint the position
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "position_nft_owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionNftOwnerAccount, false, false))
		// Account 2 "position_nft_mint": Writable, Signer, Required
		// Unique token mint address
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, true))
		// Account 3 "position_nft_account": Writable, Non-signer, Required
		// Token account where position NFT will be minted
		// This account created in the contract by cpi to avoid large stack variables
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 4 "metadata_account": Writable, Non-signer, Required
		// To store metaplex metadata
		accounts__.Append(solanago.NewAccountMeta(metadataAccountAccount, true, false))
		// Account 5 "pool_state": Writable, Non-signer, Required
		// Add liquidity for this pool
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 6 "protocol_position": Writable, Non-signer, Required
		// Store the information of market marking in range
		accounts__.Append(solanago.NewAccountMeta(protocolPositionAccount, true, false))
		// Account 7 "tick_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tickArrayLowerAccount, true, false))
		// Account 8 "tick_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tickArrayUpperAccount, true, false))
		// Account 9 "personal_position": Writable, Non-signer, Required
		// personal position state
		accounts__.Append(solanago.NewAccountMeta(personalPositionAccount, true, false))
		// Account 10 "token_account_0": Writable, Non-signer, Required
		// The token_0 account deposit token to the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAccount0account, true, false))
		// Account 11 "token_account_1": Writable, Non-signer, Required
		// The token_1 account deposit token to the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAccount1account, true, false))
		// Account 12 "token_vault_0": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 13 "token_vault_1": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 14 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		// Sysvar for token mint and ATA creation
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 15 "system_program": Read-only, Non-signer, Required
		// Program to create the position manager state account
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 16 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 17 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		// Program to create an ATA for receiving position NFT
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 18 "metadata_program": Read-only, Non-signer, Required, Address: metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s
		// Program to create NFT metadata
		accounts__.Append(solanago.NewAccountMeta(metadataProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "open_position_v2" instruction.
// #[deprecated(note = "Use `open_position_with_token22_nft` instead.")] // Creates a new position wrapped in a NFT, support Token2022 //  // # Arguments //  // * `ctx` - The context of accounts // * `tick_lower_index` - The low boundary of market // * `tick_upper_index` - The upper boundary of market // * `tick_array_lower_start_index` - The start index of tick array which include tick low // * `tick_array_upper_start_index` - The start index of tick array which include tick upper // * `liquidity` - The liquidity to be added, if zero, and the base_flag is specified, calculate liquidity base amount_0_max or amount_1_max according base_flag, otherwise open position with zero liquidity // * `amount_0_max` - The max amount of token_0 to spend, which serves as a slippage check // * `amount_1_max` - The max amount of token_1 to spend, which serves as a slippage check // * `with_metadata` - The flag indicating whether to create NFT mint metadata // * `base_flag` - if the liquidity specified as zero, true: calculate liquidity base amount_0_max otherwise base amount_1_max //
func NewOpenPositionV2Instruction(
	// Params:
	tickLowerIndexParam int32,
	tickUpperIndexParam int32,
	tickArrayLowerStartIndexParam int32,
	tickArrayUpperStartIndexParam int32,
	liquidityParam binary.Uint128,
	amount0MaxParam uint64,
	amount1MaxParam uint64,
	withMetadataParam bool,
	baseFlagParam *bool,

	// Accounts:
	payerAccount solanago.PublicKey,
	positionNftOwnerAccount solanago.PublicKey,
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	metadataAccountAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	protocolPositionAccount solanago.PublicKey,
	tickArrayLowerAccount solanago.PublicKey,
	tickArrayUpperAccount solanago.PublicKey,
	personalPositionAccount solanago.PublicKey,
	tokenAccount0account solanago.PublicKey,
	tokenAccount1account solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	metadataProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OpenPositionV2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tickLowerIndexParam`:
		err = enc__.Encode(tickLowerIndexParam)
		if err != nil {
			return nil, errors.NewField("tickLowerIndexParam", err)
		}
		// Serialize `tickUpperIndexParam`:
		err = enc__.Encode(tickUpperIndexParam)
		if err != nil {
			return nil, errors.NewField("tickUpperIndexParam", err)
		}
		// Serialize `tickArrayLowerStartIndexParam`:
		err = enc__.Encode(tickArrayLowerStartIndexParam)
		if err != nil {
			return nil, errors.NewField("tickArrayLowerStartIndexParam", err)
		}
		// Serialize `tickArrayUpperStartIndexParam`:
		err = enc__.Encode(tickArrayUpperStartIndexParam)
		if err != nil {
			return nil, errors.NewField("tickArrayUpperStartIndexParam", err)
		}
		// Serialize `liquidityParam`:
		err = enc__.Encode(liquidityParam)
		if err != nil {
			return nil, errors.NewField("liquidityParam", err)
		}
		// Serialize `amount0MaxParam`:
		err = enc__.Encode(amount0MaxParam)
		if err != nil {
			return nil, errors.NewField("amount0MaxParam", err)
		}
		// Serialize `amount1MaxParam`:
		err = enc__.Encode(amount1MaxParam)
		if err != nil {
			return nil, errors.NewField("amount1MaxParam", err)
		}
		// Serialize `withMetadataParam`:
		err = enc__.Encode(withMetadataParam)
		if err != nil {
			return nil, errors.NewField("withMetadataParam", err)
		}
		// Serialize `baseFlagParam` (optional):
		{
			if baseFlagParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("baseFlagParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("baseFlagParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(baseFlagParam)
				if err != nil {
					return nil, errors.NewField("baseFlagParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		// Pays to mint the position
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "position_nft_owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionNftOwnerAccount, false, false))
		// Account 2 "position_nft_mint": Writable, Signer, Required
		// Unique token mint address
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, true))
		// Account 3 "position_nft_account": Writable, Non-signer, Required
		// Token account where position NFT will be minted
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 4 "metadata_account": Writable, Non-signer, Required
		// To store metaplex metadata
		accounts__.Append(solanago.NewAccountMeta(metadataAccountAccount, true, false))
		// Account 5 "pool_state": Writable, Non-signer, Required
		// Add liquidity for this pool
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 6 "protocol_position": Writable, Non-signer, Required
		// Store the information of market marking in range
		accounts__.Append(solanago.NewAccountMeta(protocolPositionAccount, true, false))
		// Account 7 "tick_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tickArrayLowerAccount, true, false))
		// Account 8 "tick_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tickArrayUpperAccount, true, false))
		// Account 9 "personal_position": Writable, Non-signer, Required
		// personal position state
		accounts__.Append(solanago.NewAccountMeta(personalPositionAccount, true, false))
		// Account 10 "token_account_0": Writable, Non-signer, Required
		// The token_0 account deposit token to the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAccount0account, true, false))
		// Account 11 "token_account_1": Writable, Non-signer, Required
		// The token_1 account deposit token to the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAccount1account, true, false))
		// Account 12 "token_vault_0": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 13 "token_vault_1": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 14 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		// Sysvar for token mint and ATA creation
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 15 "system_program": Read-only, Non-signer, Required
		// Program to create the position manager state account
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 16 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 17 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		// Program to create an ATA for receiving position NFT
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 18 "metadata_program": Read-only, Non-signer, Required, Address: metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s
		// Program to create NFT metadata
		accounts__.Append(solanago.NewAccountMeta(metadataProgramAccount, false, false))
		// Account 19 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Program to create mint account and mint tokens
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 20 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token vault 0
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 21 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token vault 1
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "open_position_with_token22_nft" instruction.
// Creates a new position wrapped in a Token2022 NFT without relying on metadata_program and metadata_account, reduce the cost for user to create a personal position. //  // # Arguments //  // * `ctx` - The context of accounts // * `tick_lower_index` - The low boundary of market // * `tick_upper_index` - The upper boundary of market // * `tick_array_lower_start_index` - The start index of tick array which include tick low // * `tick_array_upper_start_index` - The start index of tick array which include tick upper // * `liquidity` - The liquidity to be added, if zero, and the base_flag is specified, calculate liquidity base amount_0_max or amount_1_max according base_flag, otherwise open position with zero liquidity // * `amount_0_max` - The max amount of token_0 to spend, which serves as a slippage check // * `amount_1_max` - The max amount of token_1 to spend, which serves as a slippage check // * `with_metadata` - The flag indicating whether to create NFT mint metadata // * `base_flag` - if the liquidity specified as zero, true: calculate liquidity base amount_0_max otherwise base amount_1_max //
func NewOpenPositionWithToken22NftInstruction(
	// Params:
	tickLowerIndexParam int32,
	tickUpperIndexParam int32,
	tickArrayLowerStartIndexParam int32,
	tickArrayUpperStartIndexParam int32,
	liquidityParam binary.Uint128,
	amount0MaxParam uint64,
	amount1MaxParam uint64,
	withMetadataParam bool,
	baseFlagParam *bool,

	// Accounts:
	payerAccount solanago.PublicKey,
	positionNftOwnerAccount solanago.PublicKey,
	positionNftMintAccount solanago.PublicKey,
	positionNftAccountAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	protocolPositionAccount solanago.PublicKey,
	tickArrayLowerAccount solanago.PublicKey,
	tickArrayUpperAccount solanago.PublicKey,
	personalPositionAccount solanago.PublicKey,
	tokenAccount0account solanago.PublicKey,
	tokenAccount1account solanago.PublicKey,
	tokenVault0account solanago.PublicKey,
	tokenVault1account solanago.PublicKey,
	rentAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	associatedTokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	vault0MintAccount solanago.PublicKey,
	vault1MintAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_OpenPositionWithToken22Nft[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `tickLowerIndexParam`:
		err = enc__.Encode(tickLowerIndexParam)
		if err != nil {
			return nil, errors.NewField("tickLowerIndexParam", err)
		}
		// Serialize `tickUpperIndexParam`:
		err = enc__.Encode(tickUpperIndexParam)
		if err != nil {
			return nil, errors.NewField("tickUpperIndexParam", err)
		}
		// Serialize `tickArrayLowerStartIndexParam`:
		err = enc__.Encode(tickArrayLowerStartIndexParam)
		if err != nil {
			return nil, errors.NewField("tickArrayLowerStartIndexParam", err)
		}
		// Serialize `tickArrayUpperStartIndexParam`:
		err = enc__.Encode(tickArrayUpperStartIndexParam)
		if err != nil {
			return nil, errors.NewField("tickArrayUpperStartIndexParam", err)
		}
		// Serialize `liquidityParam`:
		err = enc__.Encode(liquidityParam)
		if err != nil {
			return nil, errors.NewField("liquidityParam", err)
		}
		// Serialize `amount0MaxParam`:
		err = enc__.Encode(amount0MaxParam)
		if err != nil {
			return nil, errors.NewField("amount0MaxParam", err)
		}
		// Serialize `amount1MaxParam`:
		err = enc__.Encode(amount1MaxParam)
		if err != nil {
			return nil, errors.NewField("amount1MaxParam", err)
		}
		// Serialize `withMetadataParam`:
		err = enc__.Encode(withMetadataParam)
		if err != nil {
			return nil, errors.NewField("withMetadataParam", err)
		}
		// Serialize `baseFlagParam` (optional):
		{
			if baseFlagParam == nil {
				err = enc__.WriteOption(false)
				if err != nil {
					return nil, errors.NewOption("baseFlagParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
			} else {
				err = enc__.WriteOption(true)
				if err != nil {
					return nil, errors.NewOption("baseFlagParam", fmt.Errorf("error while encoding optionality: %w", err))
				}
				err = enc__.Encode(baseFlagParam)
				if err != nil {
					return nil, errors.NewField("baseFlagParam", err)
				}
			}
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Writable, Signer, Required
		// Pays to mint the position
		accounts__.Append(solanago.NewAccountMeta(payerAccount, true, true))
		// Account 1 "position_nft_owner": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionNftOwnerAccount, false, false))
		// Account 2 "position_nft_mint": Writable, Signer, Required
		// Unique token mint address, initialize in contract
		accounts__.Append(solanago.NewAccountMeta(positionNftMintAccount, true, true))
		// Account 3 "position_nft_account": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(positionNftAccountAccount, true, false))
		// Account 4 "pool_state": Writable, Non-signer, Required
		// Add liquidity for this pool
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 5 "protocol_position": Writable, Non-signer, Required
		// Store the information of market marking in range
		accounts__.Append(solanago.NewAccountMeta(protocolPositionAccount, true, false))
		// Account 6 "tick_array_lower": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tickArrayLowerAccount, true, false))
		// Account 7 "tick_array_upper": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tickArrayUpperAccount, true, false))
		// Account 8 "personal_position": Writable, Non-signer, Required
		// personal position state
		accounts__.Append(solanago.NewAccountMeta(personalPositionAccount, true, false))
		// Account 9 "token_account_0": Writable, Non-signer, Required
		// The token_0 account deposit token to the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAccount0account, true, false))
		// Account 10 "token_account_1": Writable, Non-signer, Required
		// The token_1 account deposit token to the pool
		accounts__.Append(solanago.NewAccountMeta(tokenAccount1account, true, false))
		// Account 11 "token_vault_0": Writable, Non-signer, Required
		// The address that holds pool tokens for token_0
		accounts__.Append(solanago.NewAccountMeta(tokenVault0account, true, false))
		// Account 12 "token_vault_1": Writable, Non-signer, Required
		// The address that holds pool tokens for token_1
		accounts__.Append(solanago.NewAccountMeta(tokenVault1account, true, false))
		// Account 13 "rent": Read-only, Non-signer, Required, Address: SysvarRent111111111111111111111111111111111
		// Sysvar for token mint and ATA creation
		accounts__.Append(solanago.NewAccountMeta(rentAccount, false, false))
		// Account 14 "system_program": Read-only, Non-signer, Required
		// Program to create the position manager state account
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
		// Account 15 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Program to transfer for token account
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 16 "associated_token_program": Read-only, Non-signer, Required, Address: ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL
		// Program to create an ATA for receiving position NFT
		accounts__.Append(solanago.NewAccountMeta(associatedTokenProgramAccount, false, false))
		// Account 17 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Program to create NFT mint/token account and transfer for token22 account
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 18 "vault_0_mint": Read-only, Non-signer, Required
		// The mint of token vault 0
		accounts__.Append(solanago.NewAccountMeta(vault0MintAccount, false, false))
		// Account 19 "vault_1_mint": Read-only, Non-signer, Required
		// The mint of token vault 1
		accounts__.Append(solanago.NewAccountMeta(vault1MintAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "set_reward_params" instruction.
// Reset reward param, start a new reward cycle or extend the current cycle. //  // # Arguments //  // * `ctx` - The context of accounts // * `reward_index` - The index of reward token in the pool, it must be smaller than 3 // * `emissions_per_second_x64` - The per second emission reward, when extend the current cycle, // new value can't be less than old value // * `open_time` - reward open timestamp, must be set when starting a new cycle // * `end_time` - reward end timestamp //
func NewSetRewardParamsInstruction(
	// Params:
	rewardIndexParam uint8,
	emissionsPerSecondX64Param binary.Uint128,
	openTimeParam uint64,
	endTimeParam uint64,

	// Accounts:
	authorityAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	operationStateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SetRewardParams[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `rewardIndexParam`:
		err = enc__.Encode(rewardIndexParam)
		if err != nil {
			return nil, errors.NewField("rewardIndexParam", err)
		}
		// Serialize `emissionsPerSecondX64Param`:
		err = enc__.Encode(emissionsPerSecondX64Param)
		if err != nil {
			return nil, errors.NewField("emissionsPerSecondX64Param", err)
		}
		// Serialize `openTimeParam`:
		err = enc__.Encode(openTimeParam)
		if err != nil {
			return nil, errors.NewField("openTimeParam", err)
		}
		// Serialize `endTimeParam`:
		err = enc__.Encode(endTimeParam)
		if err != nil {
			return nil, errors.NewField("endTimeParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required
		// Address to be set as protocol owner. It pays to create factory state account.
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "amm_config": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "operation_state": Read-only, Non-signer, Required
		// load info from the account to judge reward permission
		accounts__.Append(solanago.NewAccountMeta(operationStateAccount, false, false))
		// Account 4 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// Token program
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 5 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// Token program 2022
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap" instruction.
// #[deprecated(note = "Use `swap_v2` instead.")] // Swaps one token for as much as possible of another token across a single pool //  // # Arguments //  // * `ctx` - The context of accounts // * `amount` - Arranged in pairs with other_amount_threshold. (amount_in, amount_out_minimum) or (amount_out, amount_in_maximum) // * `other_amount_threshold` - For slippage check // * `sqrt_price_limit_x64` - The Q64.64 format P limit price, and if it is 0, the maximum and minimum prices that can be reached are set by default according to the swap direction. // * `is_base_input` - swap base input or swap base output //
func NewSwapInstruction(
	// Params:
	amountParam uint64,
	otherAmountThresholdParam uint64,
	sqrtPriceLimitX64Param binary.Uint128,
	isBaseInputParam bool,

	// Accounts:
	payerAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	inputTokenAccountAccount solanago.PublicKey,
	outputTokenAccountAccount solanago.PublicKey,
	inputVaultAccount solanago.PublicKey,
	outputVaultAccount solanago.PublicKey,
	observationStateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tickArrayAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_Swap[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `otherAmountThresholdParam`:
		err = enc__.Encode(otherAmountThresholdParam)
		if err != nil {
			return nil, errors.NewField("otherAmountThresholdParam", err)
		}
		// Serialize `sqrtPriceLimitX64Param`:
		err = enc__.Encode(sqrtPriceLimitX64Param)
		if err != nil {
			return nil, errors.NewField("sqrtPriceLimitX64Param", err)
		}
		// Serialize `isBaseInputParam`:
		err = enc__.Encode(isBaseInputParam)
		if err != nil {
			return nil, errors.NewField("isBaseInputParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Read-only, Signer, Required
		// The user performing the swap
		accounts__.Append(solanago.NewAccountMeta(payerAccount, false, true))
		// Account 1 "amm_config": Read-only, Non-signer, Required
		// The factory state to read protocol fees
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		// The program account of the pool in which the swap will be performed
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "input_token_account": Writable, Non-signer, Required
		// The user token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputTokenAccountAccount, true, false))
		// Account 4 "output_token_account": Writable, Non-signer, Required
		// The user token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputTokenAccountAccount, true, false))
		// Account 5 "input_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputVaultAccount, true, false))
		// Account 6 "output_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputVaultAccount, true, false))
		// Account 7 "observation_state": Writable, Non-signer, Required
		// The program account for the most recent oracle observation
		accounts__.Append(solanago.NewAccountMeta(observationStateAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// SPL program for token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "tick_array": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(tickArrayAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap_router_base_in" instruction.
// Swap token for as much as possible of another token across the path provided, base input //  // # Arguments //  // * `ctx` - The context of accounts // * `amount_in` - Token amount to be swapped in // * `amount_out_minimum` - Minimum output amount for slip control
func NewSwapRouterBaseInInstruction(
	// Params:
	amountInParam uint64,
	amountOutMinimumParam uint64,

	// Accounts:
	payerAccount solanago.PublicKey,
	inputTokenAccountAccount solanago.PublicKey,
	inputTokenMintAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SwapRouterBaseIn[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountInParam`:
		err = enc__.Encode(amountInParam)
		if err != nil {
			return nil, errors.NewField("amountInParam", err)
		}
		// Serialize `amountOutMinimumParam`:
		err = enc__.Encode(amountOutMinimumParam)
		if err != nil {
			return nil, errors.NewField("amountOutMinimumParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Read-only, Signer, Required
		// The user performing the swap
		accounts__.Append(solanago.NewAccountMeta(payerAccount, false, true))
		// Account 1 "input_token_account": Writable, Non-signer, Required
		// The token account that pays input tokens for the swap
		accounts__.Append(solanago.NewAccountMeta(inputTokenAccountAccount, true, false))
		// Account 2 "input_token_mint": Writable, Non-signer, Required
		// The mint of input token
		accounts__.Append(solanago.NewAccountMeta(inputTokenMintAccount, true, false))
		// Account 3 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// SPL program for token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 4 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// SPL program 2022 for token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 5 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		// Memo program
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "swap_v2" instruction.
// Swaps one token for as much as possible of another token across a single pool, support token program 2022 //  // # Arguments //  // * `ctx` - The context of accounts // * `amount` - Arranged in pairs with other_amount_threshold. (amount_in, amount_out_minimum) or (amount_out, amount_in_maximum) // * `other_amount_threshold` - For slippage check // * `sqrt_price_limit` - The Q64.64 format P limit price, and if it is 0, the maximum and minimum prices that can be reached are set by default according to the swap direction. // * `is_base_input` - swap base input or swap base output //
func NewSwapV2Instruction(
	// Params:
	amountParam uint64,
	otherAmountThresholdParam uint64,
	sqrtPriceLimitX64Param binary.Uint128,
	isBaseInputParam bool,

	// Accounts:
	payerAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
	inputTokenAccountAccount solanago.PublicKey,
	outputTokenAccountAccount solanago.PublicKey,
	inputVaultAccount solanago.PublicKey,
	outputVaultAccount solanago.PublicKey,
	observationStateAccount solanago.PublicKey,
	tokenProgramAccount solanago.PublicKey,
	tokenProgram2022account solanago.PublicKey,
	memoProgramAccount solanago.PublicKey,
	inputVaultMintAccount solanago.PublicKey,
	outputVaultMintAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_SwapV2[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `amountParam`:
		err = enc__.Encode(amountParam)
		if err != nil {
			return nil, errors.NewField("amountParam", err)
		}
		// Serialize `otherAmountThresholdParam`:
		err = enc__.Encode(otherAmountThresholdParam)
		if err != nil {
			return nil, errors.NewField("otherAmountThresholdParam", err)
		}
		// Serialize `sqrtPriceLimitX64Param`:
		err = enc__.Encode(sqrtPriceLimitX64Param)
		if err != nil {
			return nil, errors.NewField("sqrtPriceLimitX64Param", err)
		}
		// Serialize `isBaseInputParam`:
		err = enc__.Encode(isBaseInputParam)
		if err != nil {
			return nil, errors.NewField("isBaseInputParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "payer": Read-only, Signer, Required
		// The user performing the swap
		accounts__.Append(solanago.NewAccountMeta(payerAccount, false, true))
		// Account 1 "amm_config": Read-only, Non-signer, Required
		// The factory state to read protocol fees
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, false, false))
		// Account 2 "pool_state": Writable, Non-signer, Required
		// The program account of the pool in which the swap will be performed
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
		// Account 3 "input_token_account": Writable, Non-signer, Required
		// The user token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputTokenAccountAccount, true, false))
		// Account 4 "output_token_account": Writable, Non-signer, Required
		// The user token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputTokenAccountAccount, true, false))
		// Account 5 "input_vault": Writable, Non-signer, Required
		// The vault token account for input token
		accounts__.Append(solanago.NewAccountMeta(inputVaultAccount, true, false))
		// Account 6 "output_vault": Writable, Non-signer, Required
		// The vault token account for output token
		accounts__.Append(solanago.NewAccountMeta(outputVaultAccount, true, false))
		// Account 7 "observation_state": Writable, Non-signer, Required
		// The program account for the most recent oracle observation
		accounts__.Append(solanago.NewAccountMeta(observationStateAccount, true, false))
		// Account 8 "token_program": Read-only, Non-signer, Required, Address: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
		// SPL program for token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgramAccount, false, false))
		// Account 9 "token_program_2022": Read-only, Non-signer, Required, Address: TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb
		// SPL program 2022 for token transfers
		accounts__.Append(solanago.NewAccountMeta(tokenProgram2022account, false, false))
		// Account 10 "memo_program": Read-only, Non-signer, Required, Address: MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr
		// Memo program
		accounts__.Append(solanago.NewAccountMeta(memoProgramAccount, false, false))
		// Account 11 "input_vault_mint": Read-only, Non-signer, Required
		// The mint of token vault 0
		accounts__.Append(solanago.NewAccountMeta(inputVaultMintAccount, false, false))
		// Account 12 "output_vault_mint": Read-only, Non-signer, Required
		// The mint of token vault 1
		accounts__.Append(solanago.NewAccountMeta(outputVaultMintAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "transfer_reward_owner" instruction.
// Transfer reward owner //  // # Arguments //  // * `ctx`- The context of accounts // * `new_owner`- new owner pubkey //
func NewTransferRewardOwnerInstruction(
	// Params:
	newOwnerParam solanago.PublicKey,

	// Accounts:
	authorityAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_TransferRewardOwner[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `newOwnerParam`:
		err = enc__.Encode(newOwnerParam)
		if err != nil {
			return nil, errors.NewField("newOwnerParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		// Address to be set as operation account owner.
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_amm_config" instruction.
// Updates the owner of the amm config // Must be called by the current owner or admin //  // # Arguments //  // * `ctx`- The context of accounts // * `trade_fee_rate`- The new trade fee rate of amm config, be set when `param` is 0 // * `protocol_fee_rate`- The new protocol fee rate of amm config, be set when `param` is 1 // * `fund_fee_rate`- The new fund fee rate of amm config, be set when `param` is 2 // * `new_owner`- The config's new owner, be set when `param` is 3 // * `new_fund_owner`- The config's new fund owner, be set when `param` is 4 // * `param`- The value can be 0 | 1 | 2 | 3 | 4, otherwise will report a error //
func NewUpdateAmmConfigInstruction(
	// Params:
	paramParam uint8,
	valueParam uint32,

	// Accounts:
	ownerAccount solanago.PublicKey,
	ammConfigAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateAmmConfig[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramParam`:
		err = enc__.Encode(paramParam)
		if err != nil {
			return nil, errors.NewField("paramParam", err)
		}
		// Serialize `valueParam`:
		err = enc__.Encode(valueParam)
		if err != nil {
			return nil, errors.NewField("valueParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		// The amm config owner or admin
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "amm_config": Writable, Non-signer, Required
		// Amm config account to be changed
		accounts__.Append(solanago.NewAccountMeta(ammConfigAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_operation_account" instruction.
// Update the operation account //  // # Arguments //  // * `ctx`- The context of accounts // * `param`- The value can be 0 | 1 | 2 | 3, otherwise will report a error // * `keys`- update operation owner when the `param` is 0 // remove operation owner when the `param` is 1 // update whitelist mint when the `param` is 2 // remove whitelist mint when the `param` is 3 //
func NewUpdateOperationAccountInstruction(
	// Params:
	paramParam uint8,
	keysParam []solanago.PublicKey,

	// Accounts:
	ownerAccount solanago.PublicKey,
	operationStateAccount solanago.PublicKey,
	systemProgramAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdateOperationAccount[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `paramParam`:
		err = enc__.Encode(paramParam)
		if err != nil {
			return nil, errors.NewField("paramParam", err)
		}
		// Serialize `keysParam`:
		err = enc__.Encode(keysParam)
		if err != nil {
			return nil, errors.NewField("keysParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "owner": Read-only, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		// Address to be set as operation account owner.
		accounts__.Append(solanago.NewAccountMeta(ownerAccount, false, true))
		// Account 1 "operation_state": Writable, Non-signer, Required
		// Initialize operation state account to store operation owner address and white list mint.
		accounts__.Append(solanago.NewAccountMeta(operationStateAccount, true, false))
		// Account 2 "system_program": Read-only, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(systemProgramAccount, false, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_pool_status" instruction.
// Update pool status for given value //  // # Arguments //  // * `ctx`- The context of accounts // * `status` - The value of status //
func NewUpdatePoolStatusInstruction(
	// Params:
	statusParam uint8,

	// Accounts:
	authorityAccount solanago.PublicKey,
	poolStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	buf__ := new(bytes.Buffer)
	enc__ := binary.NewBorshEncoder(buf__)

	// Encode the instruction discriminator.
	err := enc__.WriteBytes(Instruction_UpdatePoolStatus[:], false)
	if err != nil {
		return nil, fmt.Errorf("failed to write instruction discriminator: %w", err)
	}
	{
		// Serialize `statusParam`:
		err = enc__.Encode(statusParam)
		if err != nil {
			return nil, errors.NewField("statusParam", err)
		}
	}
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "authority": Read-only, Signer, Required, Address: GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ
		accounts__.Append(solanago.NewAccountMeta(authorityAccount, false, true))
		// Account 1 "pool_state": Writable, Non-signer, Required
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		buf__.Bytes(),
	), nil
}

// Builds a "update_reward_infos" instruction.
// Update rewards info of the given pool, can be called for everyone //  // # Arguments //  // * `ctx`- The context of accounts //
func NewUpdateRewardInfosInstruction(
	poolStateAccount solanago.PublicKey,
) (solanago.Instruction, error) {
	accounts__ := solanago.AccountMetaSlice{}

	// Add the accounts to the instruction.
	{
		// Account 0 "pool_state": Writable, Non-signer, Required
		// The liquidity pool for which reward info to update
		accounts__.Append(solanago.NewAccountMeta(poolStateAccount, true, false))
	}

	// Create the instruction.
	return solanago.NewInstruction(
		ProgramID,
		accounts__,
		nil,
	), nil
}
